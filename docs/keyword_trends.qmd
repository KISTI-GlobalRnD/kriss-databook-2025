---
title: "Keyword Trend Explorer / 키워드 추세 탐색기"
description: "Interactive plot of top-ranked keywords by research cluster and metric."
page-title: false
---

# Keyword Trend Explorer / 키워드 추세 탐색기

Interactively inspect how the highest-ranked keywords evolve across years for each research cluster.
Use the selectors to switch between clusters and metrics while the legend lets you toggle individual
keyword curves on and off. All data are sourced from the latest `_top5` time series export.

::: callout-tip
모든 곡선은 문헌 비중(`ppm_series_val`, parts-per-million)을 나타냅니다. 포인트에 마우스를 올리면
각 용어의 `score`(c‑TF‑IDF)와 `frequency`(문헌 수)를 함께 확인할 수 있습니다.
:::

<style>
  .keyword-timeseries-wrapper {
    border: 1px solid #dee2e6;
    border-radius: 0.5rem;
    padding: 1.25rem;
    margin-bottom: 1.5rem;
    background: #f8f9fa;
  }
  .keyword-timeseries-controls {
    display: flex;
    flex-wrap: wrap;
    align-items: center;
    gap: 1.5rem;
    margin-bottom: 1.25rem;
  }
  .keyword-timeseries-controls label {
    display: block;
    font-weight: 600;
    margin-bottom: 0.35rem;
  }
  .keyword-timeseries-controls select {
    min-width: 16rem;
  }
  .keyword-timeseries-meta {
    margin-top: 1.25rem;
    font-size: 0.95rem;
    line-height: 1.55;
  }
  .keyword-timeseries-meta strong {
    font-weight: 600;
  }
  .keyword-timeseries-defs {
    margin-top: 1.75rem;
    padding: 1rem 1.2rem;
    border-left: 4px solid #2c7be5;
    background: #ffffff;
  }
  .keyword-timeseries-defs p {
    margin-bottom: 0.4rem;
  }
  .keyword-timeseries-defs p:last-child {
    margin-bottom: 0;
  }
  .keyword-sparklines {
    margin-top: 2rem;
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(320px, 1fr));
    gap: 1rem 1.5rem;
  }
  .keyword-sparklines .sparkline-card {
    border: 1px solid #dee2e6;
    border-radius: 0.5rem;
    padding: 0.5rem 0.75rem 0.65rem;
    background: #fff;
    box-shadow: 0 1px 3px rgba(33, 37, 41, 0.05);
  }
  .keyword-sparklines .sparkline-title {
    font-size: 0.9rem;
    font-weight: 600;
    margin-bottom: 0.35rem;
    color: #1f2933;
  }
  .keyword-sparklines svg {
    width: 100%;
    height: 60px;
  }
  .keyword-sparklines .sparkline-note {
    font-size: 0.78rem;
    color: #495057;
    margin-top: 0.35rem;
  }
</style>

<script src="https://cdn.plot.ly/plotly-2.27.1.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/d3@7/dist/d3.min.js"></script>

<div class="keyword-timeseries-wrapper">
<div class="keyword-timeseries-controls" id="keyword-timeseries-controls"></div>
<div id="keyword-timeseries-chart" style="width: 100%; min-height: 520px;"></div>
<div class="keyword-timeseries-meta" id="keyword-timeseries-meta"></div>
<div class="keyword-timeseries-defs">
  <p><strong>Document Share (PPM)</strong> · Parts per million of the cluster’s total unigram tokens for each term-year pair. \( \mathrm{PPM}_{c,y}(t) = 10^{6} \cdot \frac{n_{c,y}(t)}{N_{c,y}} \)</p>
  <p><strong>Score</strong> · Cluster-specific c‑TF‑IDF weight used to rank keywords (constant across years).</p>
  <p><strong>Frequency</strong> · Count of documents within the cluster that contain the keyword (constant across years).</p>
  <p>Both <em>Score</em> and <em>Frequency</em> appear inside the hover tooltips for each point.</p>
</div>
</div>

<div class="keyword-sparklines" id="keyword-timeseries-sparklines"></div>

<script>
(() => {
  const dataUrl = "assets/keyword_top5_timeseries.csv";
  const chartEl = document.getElementById("keyword-timeseries-chart");
  const controlsEl = document.getElementById("keyword-timeseries-controls");
  const clusterGroup = document.createElement("div");
  const clusterLabel = document.createElement("label");
  clusterLabel.setAttribute("for", "cluster-select");
  clusterLabel.textContent = "Cluster / 클러스터";
  const clusterSelect = document.createElement("select");
  clusterSelect.id = "cluster-select";
  clusterSelect.setAttribute("aria-label", "Select cluster");
  clusterGroup.appendChild(clusterLabel);
  clusterGroup.appendChild(clusterSelect);
  controlsEl.appendChild(clusterGroup);
  const metaEl = document.getElementById("keyword-timeseries-meta");
  const sparklinesEl = document.getElementById("keyword-timeseries-sparklines");

  const metricKey = "ppm_series_val";
  const metricLabel = "Document Share (PPM)";
  const maxSparklines = 40;

  function cleanText(value) {
    if (value === null || value === undefined) {
      return "";
    }
    const text = String(value).trim();
    if (!text) {
      return "";
    }
    const lower = text.toLowerCase();
    if (lower === "nan" || lower === "none" || lower === "null") {
      return "";
    }
    return text;
  }

  function summariseCluster(cluster) {
    const { id, rows } = cluster;
    const sample = rows[0] || {};
    const label = cleanText(sample.short_label_kr) || cleanText(sample.cluster_micro) || `Cluster ${id}`;
    const longLabel = cleanText(sample.long_label_kr);
    const summary = cleanText(sample.summary_kr);

    const keywordsEnRaw = cleanText(sample.keywords_en);
    const keywordsKrRaw = cleanText(sample.keywords_kr);
    const keywordsEn = keywordsEnRaw
      ? keywordsEnRaw.split(",").map(part => part.trim()).filter(Boolean).slice(0, 5).join(", ")
      : "";
    const keywordsKr = keywordsKrRaw
      ? keywordsKrRaw.split(",").map(part => part.trim()).filter(Boolean).slice(0, 5).join(", ")
      : "";

    const termList = Array.from(new Set(rows.map(r => r.term))).slice(0, 5);

    const lines = [
      `<strong>${label}</strong>${longLabel ? ` (${longLabel})` : ""}`,
      termList.length ? `Top terms: ${termList.join(", ")}` : "",
      keywordsEn ? `Keywords (EN): ${keywordsEn}` : "",
      keywordsKr ? `키워드 (KO): ${keywordsKr}` : "",
      summary ? `요약: ${summary}` : ""
    ].filter(Boolean);

    metaEl.innerHTML = lines.map(line => `<p>${line}</p>`).join("");
  }

  function buildTraces(cluster) {
    const rowsByTerm = new Map();
    cluster.rows.forEach(row => {
      const termRows = rowsByTerm.get(row.term) || [];
      termRows.push(row);
      rowsByTerm.set(row.term, termRows);
    });

    const traces = [];
    rowsByTerm.forEach((termRows, term) => {
      const sorted = termRows
        .filter(r => r.year !== null && r.year !== undefined && !Number.isNaN(r.year))
        .sort((a, b) => a.year - b.year);
      if (!sorted.length) {
        return;
      }
      traces.push({
        name: term,
        x: sorted.map(r => r.year),
        y: sorted.map(r => r[metricKey]),
        hovertemplate:
          "<b>%{customdata[0]}</b><br>" +
          "Year: %{x}<br>" +
          "Document Share (PPM): %{y:.2f}<br>" +
          "Score: %{customdata[1]:.3f}<br>" +
          "Frequency: %{customdata[2]:,.0f}<extra></extra>",
        customdata: sorted.map(r => [term, r.score ?? null, r.frequency ?? null]),
        mode: "lines+markers",
        line: { width: 2 },
        marker: { size: 6 }
      });
    });
    return traces;
  }

  function updateChart(cluster) {
    const traces = buildTraces(cluster);
    const years = cluster.rows
      .map(r => r.year)
      .filter(year => year !== null && year !== undefined && !Number.isNaN(year));
    const minYear = years.length ? Math.min(...years) : null;
    const maxYear = years.length ? Math.max(...years) : null;
    const yearRange = minYear !== null && maxYear !== null ? [minYear, maxYear] : null;

    const layout = {
      title: {
        text: `Cluster ${cluster.id} · ${metricLabel}`,
        font: { size: 20 }
      },
      xaxis: {
        title: "Year",
        dtick: 1,
        range: yearRange ? [yearRange[0] - 0.5, yearRange[1] + 0.5] : undefined,
        tickformat: "d",
        hoverformat: "d"
      },
      yaxis: {
        title: metricLabel,
        rangemode: "tozero",
        hoverformat: ".2f"
      },
      legend: {
        orientation: "h",
        yanchor: "bottom",
        y: -0.2,
        xanchor: "center",
        x: 0.5
      },
      margin: { l: 70, r: 30, t: 60, b: 80 },
      hoverlabel: { bgcolor: "#343a40", font: { color: "#fff" } }
    };

    const config = {
      responsive: true,
      displaylogo: false,
      modeBarButtonsToRemove: [
        "lasso2d",
        "select2d",
        "autoScale2d",
        "zoomIn2d",
        "zoomOut2d",
        "resetScale2d"
      ]
    };

    Plotly.react(chartEl, traces, layout, config);
    return yearRange;
  }

  function renderSparklines(cluster, yearRange) {
    sparklinesEl.innerHTML = "";

    const rowsByTerm = new Map();
    cluster.rows.forEach(row => {
      const collection = rowsByTerm.get(row.term) || [];
      collection.push(row);
      rowsByTerm.set(row.term, collection);
    });

    const termSeries = [];
    rowsByTerm.forEach((termRows, term) => {
      const sorted = termRows
        .filter(r => r.year !== null && r.year !== undefined && !Number.isNaN(r.year))
        .sort((a, b) => a.year - b.year);
      if (!sorted.length) {
        return;
      }
      const base = sorted[0];
      termSeries.push({
        term,
        rows: sorted,
        score: base.score ?? null,
        frequency: base.frequency ?? null
      });
    });

    if (!termSeries.length) {
      sparklinesEl.innerHTML = "<p>시각화할 키워드 시계열이 없습니다.</p>";
      return;
    }

    termSeries.sort((a, b) => (b.score ?? 0) - (a.score ?? 0));
    const termsToRender = termSeries.slice(0, maxSparklines);

    const globalYearRange = yearRange || (() => {
      const years = cluster.rows
        .map(r => r.year)
        .filter(y => y !== null && y !== undefined && !Number.isNaN(y));
      if (!years.length) {
        return null;
      }
      return [Math.min(...years), Math.max(...years)];
    })();

    termsToRender.forEach(termData => {
      const { term, rows, score, frequency } = termData;
      const container = document.createElement("div");
      container.className = "sparkline-card";

      const title = document.createElement("div");
      title.className = "sparkline-title";
      title.textContent = term;
      container.appendChild(title);

      const svg = d3.create("svg")
        .attr("viewBox", "0 0 320 70")
        .attr("role", "img")
        .attr("aria-label", `${term} document share trend`);

      const margin = { top: 8, right: 48, bottom: 16, left: 48 };
      const width = 320 - margin.left - margin.right;
      const height = 70 - margin.top - margin.bottom;

      const x = d3.scaleLinear()
        .domain(globalYearRange || [
          d3.min(rows, d => d.year),
          d3.max(rows, d => d.year)
        ])
        .range([0, width]);

      const ppmValues = rows
        .map(r => r[metricKey])
        .filter(value => Number.isFinite(value));

      const minVal = d3.min(ppmValues);
      const maxVal = d3.max(ppmValues);
      const padding = (maxVal - minVal) * 0.1 || (maxVal || 1) * 0.1;
      const y = d3.scaleLinear()
        .domain([
          Math.max(0, (minVal ?? 0) - padding),
          (maxVal ?? 0) + padding
        ])
        .range([height, 0]);

      const area = d3.area()
        .x(d => x(d.year))
        .y0(y(0))
        .y1(d => y(d[metricKey] ?? 0))
        .defined(d => Number.isFinite(d[metricKey]));

      const line = d3.line()
        .x(d => x(d.year))
        .y(d => y(d[metricKey] ?? 0))
        .defined(d => Number.isFinite(d[metricKey]));

      const chart = svg.append("g")
        .attr("transform", `translate(${margin.left},${margin.top})`);

      chart.append("path")
        .datum(rows)
        .attr("fill", "rgba(76, 114, 176, 0.25)")
        .attr("d", area);

      chart.append("path")
        .datum(rows)
        .attr("fill", "none")
        .attr("stroke", "#4C72B0")
        .attr("stroke-width", 1.3)
        .attr("d", line);

      const first = rows[0];
      const last = rows[rows.length - 1];

      chart.selectAll(".endpoint")
        .data([first, last])
        .join("circle")
        .attr("class", "endpoint")
        .attr("cx", d => x(d.year))
        .attr("cy", d => y(d[metricKey] ?? 0))
        .attr("r", 3.5)
        .attr("fill", "#4C72B0");

      const firstValue = Number.isFinite(first[metricKey]) ? first[metricKey].toFixed(2) : "-";
      const lastValue = Number.isFinite(last[metricKey]) ? last[metricKey].toFixed(2) : "-";

      chart.append("text")
        .attr("x", x(first.year) - 6)
        .attr("y", y(first[metricKey] ?? 0) - 4)
        .attr("text-anchor", "end")
        .attr("font-size", "10px")
        .attr("fill", "#4C72B0")
        .text(firstValue);

      chart.append("text")
        .attr("x", x(last.year) + 6)
        .attr("y", y(last[metricKey] ?? 0) - 4)
        .attr("text-anchor", "start")
        .attr("font-size", "10px")
        .attr("fill", "#4C72B0")
        .text(lastValue);

      chart.append("text")
        .attr("x", width / 2)
        .attr("y", height + 12)
        .attr("text-anchor", "middle")
        .attr("font-size", "9px")
        .attr("fill", "#6c757d")
        .text("Year");

      container.appendChild(svg.node());

      const note = document.createElement("div");
      note.className = "sparkline-note";
      const scoreText = Number.isFinite(score) ? score.toFixed(2) : "-";
      const freqText = Number.isFinite(frequency) ? frequency.toLocaleString() : "-";
      note.textContent = `Score ${scoreText} · Freq ${freqText}`;
      container.appendChild(note);

      sparklinesEl.appendChild(container);
    });
  }

  function initialiseControls(clusters) {
    const clusterOptions = Array.from(clusters.values())
      .sort((a, b) => a.id - b.id)
      .map(cluster => {
        const sample = cluster.rows[0] || {};
        const labelParts = [];
        const shortLabel = cleanText(sample.short_label_kr);
        const micro = cleanText(sample.cluster_micro);
        if (shortLabel) {
          labelParts.push(shortLabel);
        }
        if (micro) {
          labelParts.push(micro);
        }
        const label = labelParts.length ? labelParts.join(" · ") : `Cluster ${cluster.id}`;
        return { value: cluster.id, label };
      });

    clusterSelect.innerHTML = "";
    if (!clusterOptions.length) {
      clusterSelect.disabled = true;
      clusterSelect.innerHTML = "<option>No clusters available</option>";
      return clusterOptions;
    }

    clusterOptions.forEach(option => {
      const opt = document.createElement("option");
      opt.value = option.value;
      opt.textContent = `${option.value} · ${option.label}`;
      clusterSelect.appendChild(opt);
    });

    return clusterOptions;
  }

  function loadData() {
    d3.csv(dataUrl).then(rows => {
      const clusters = new Map();

      rows.forEach(rawRow => {
        if (!rawRow) {
          return;
        }
        const row = { ...rawRow };
        row.cluster_id = Number.parseInt(row.cluster_id, 10);
        row.year = row.year ? Number.parseInt(row.year, 10) : null;
        row.rank = row.rank ? Number.parseInt(row.rank, 10) : null;
        row.score = row.score ? Number.parseFloat(row.score) : null;
        row.ppm_series_val = row.ppm_series_val ? Number.parseFloat(row.ppm_series_val) : null;
        row.frequency = row.frequency ? Number.parseFloat(row.frequency) : null;

        if (!Number.isFinite(row.cluster_id)) {
          return;
        }

        const key = row.cluster_id;
        if (!clusters.has(key)) {
          clusters.set(key, { id: key, rows: [] });
        }
        clusters.get(key).rows.push(row);
      });

      if (!clusters.size) {
        metaEl.innerHTML = "<p>가공할 클러스터 데이터가 없습니다.</p>";
        return;
      }

      const options = initialiseControls(clusters);
      const initialClusterId = options[0]?.value;

      function handleUpdate() {
        const selectedId = Number.parseInt(clusterSelect.value, 10);
        const cluster = clusters.get(selectedId);
        if (!cluster) {
          metaEl.innerHTML = "<p>선택한 클러스터에 대한 데이터가 없습니다.</p>";
          Plotly.purge(chartEl);
          sparklinesEl.innerHTML = "";
          return;
        }
        const yearRange = updateChart(cluster);
        summariseCluster(cluster);
        renderSparklines(cluster, yearRange);
      }

      if (initialClusterId !== undefined) {
        clusterSelect.value = String(initialClusterId);
        handleUpdate();
      }

      clusterSelect.addEventListener("change", handleUpdate);
    }).catch(err => {
      console.error("Failed to load keyword time series.", err);
      metaEl.innerHTML = "<p>데이터를 불러오지 못했습니다. CSV 경로 또는 접근 권한을 확인하세요.</p>";
    });
  }

  loadData();
})();
</script>
