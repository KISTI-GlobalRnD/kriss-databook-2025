---
title: "Keyword Trend Explorer / 키워드 추세 탐색기"
description: "Interactive plot of top-ranked keywords by research cluster and metric."
page-title: false
---

# Keyword Trend Explorer / 키워드 추세 탐색기

Interactively inspect how the highest-ranked keywords evolve across years for each research cluster.
Use the selectors to switch between clusters and metrics while the legend lets you toggle individual
keyword curves on and off. All data are sourced from the latest `_top5` time series export.

::: callout-tip
키워드 지표는 하나의 클러스터 안에서 점수(`score`), 문헌 비중(`ppm_series_val`), 출현 빈도(`frequency`)
중에서 선택할 수 있습니다. 범례를 클릭하면 개별 키워드를 강조하거나 숨길 수 있습니다.
:::

<style>
  .keyword-timeseries-wrapper {
    border: 1px solid #dee2e6;
    border-radius: 0.5rem;
    padding: 1.25rem;
    margin-bottom: 1.5rem;
    background: #f8f9fa;
  }
  .keyword-timeseries-controls {
    display: flex;
    flex-wrap: wrap;
    align-items: center;
    gap: 1rem;
    margin-bottom: 1rem;
  }
  .keyword-timeseries-controls label {
    font-weight: 600;
    margin-right: 0.5rem;
  }
  .keyword-timeseries-controls select {
    min-width: 14rem;
  }
  .keyword-timeseries-meta {
    margin-top: 1rem;
    font-size: 0.95rem;
    line-height: 1.5;
  }
  .keyword-timeseries-meta strong {
    font-weight: 600;
  }
</style>

<script src="https://cdn.plot.ly/plotly-2.27.1.min.js"></script>

<div class="keyword-timeseries-wrapper">
<div class="keyword-timeseries-controls">
<div class="keyword-timeseries-control">
<label for="cluster-select">Cluster / 클러스터</label>
<select id="cluster-select" aria-label="Select cluster"></select>
</div>
<div class="keyword-timeseries-control">
<label for="metric-select">Metric / 지표</label>
<select id="metric-select" aria-label="Select metric">
<option value="score">TF-IDF Score (score)</option>
<option value="ppm_series_val">Document Share (ppm_series_val)</option>
<option value="frequency">Frequency (frequency)</option>
</select>
</div>
</div>
<div id="keyword-timeseries-chart" style="width: 100%; min-height: 520px;"></div>
<div class="keyword-timeseries-meta" id="keyword-timeseries-meta"></div>
</div>

<script>
(() => {
  const dataUrl = "assets/keyword_top5_timeseries.csv";
  const chartEl = document.getElementById("keyword-timeseries-chart");
  const clusterSelect = document.getElementById("cluster-select");
  const metricSelect = document.getElementById("metric-select");
  const metaEl = document.getElementById("keyword-timeseries-meta");

  const metricConfig = {
    score: { label: "TF-IDF Score", description: "Keyword weight derived from c-TF-IDF" },
    ppm_series_val: { label: "Document Share (ppm)", description: "Proportion of documents per million" },
    frequency: { label: "Raw Frequency", description: "Document count containing the keyword" }
  };

  function cleanText(value) {
    if (value === null || value === undefined) {
      return "";
    }
    const text = String(value).trim();
    if (!text) {
      return "";
    }
    const lower = text.toLowerCase();
    if (lower === "nan" || lower === "none" || lower === "null") {
      return "";
    }
    return text;
  }

  function summariseCluster(cluster) {
    const { id, rows } = cluster;
    const sample = rows[0] || {};
    const label = cleanText(sample.short_label_kr) || cleanText(sample.cluster_micro) || `Cluster ${id}`;
    const longLabel = cleanText(sample.long_label_kr);
    const summary = cleanText(sample.summary_kr);

    const keywordsEnRaw = cleanText(sample.keywords_en);
    const keywordsKrRaw = cleanText(sample.keywords_kr);
    const keywordsEn = keywordsEnRaw
      ? keywordsEnRaw.split(",").map(part => part.trim()).filter(Boolean).slice(0, 5).join(", ")
      : "";
    const keywordsKr = keywordsKrRaw
      ? keywordsKrRaw.split(",").map(part => part.trim()).filter(Boolean).slice(0, 5).join(", ")
      : "";

    const termList = Array.from(new Set(rows.map(r => r.term))).slice(0, 5);

    const lines = [
      `<strong>${label}</strong>${longLabel ? ` (${longLabel})` : ""}`,
      termList.length ? `Top terms: ${termList.join(", ")}` : "",
      keywordsEn ? `Keywords (EN): ${keywordsEn}` : "",
      keywordsKr ? `키워드 (KO): ${keywordsKr}` : "",
      summary ? `요약: ${summary}` : ""
    ].filter(Boolean);

    metaEl.innerHTML = lines.map(line => `<p>${line}</p>`).join("");
  }

  function buildTraces(cluster, metricKey) {
    const rowsByTerm = new Map();
    cluster.rows.forEach(row => {
      const termRows = rowsByTerm.get(row.term) || [];
      termRows.push(row);
      rowsByTerm.set(row.term, termRows);
    });

    const traces = [];
    rowsByTerm.forEach((termRows, term) => {
      const sorted = termRows
        .filter(r => r.year !== null && r.year !== undefined && !Number.isNaN(r.year))
        .sort((a, b) => a.year - b.year);
      if (!sorted.length) {
        return;
      }
      traces.push({
        name: term,
        x: sorted.map(r => r.year),
        y: sorted.map(r => r[metricKey]),
        text: sorted.map(r => `Rank ${r.rank}`),
        hovertemplate:
          "<b>%{text}</b><br>Term: %{meta.term}<br>Year: %{x}<br>" +
          `${metricConfig[metricKey].label}: %{y:.3f}<extra></extra>`,
        meta: { term },
        mode: "lines+markers",
        line: { width: 2 },
        marker: { size: 6 }
      });
    });
    return traces;
  }

  function updateChart(cluster, metricKey) {
    const traces = buildTraces(cluster, metricKey);
    const metric = metricConfig[metricKey];
    const years = cluster.rows
      .map(r => r.year)
      .filter(year => year !== null && year !== undefined && !Number.isNaN(year));
    const minYear = years.length ? Math.min(...years) : null;
    const maxYear = years.length ? Math.max(...years) : null;

    const layout = {
      title: {
        text: `Cluster ${cluster.id} · ${metric.label}`,
        font: { size: 20 }
      },
      xaxis: {
        title: "Year",
        dtick: 1,
        range: minYear !== null && maxYear !== null ? [minYear - 0.5, maxYear + 0.5] : undefined,
        tickformat: "d",
        hoverformat: "d"
      },
      yaxis: {
        title: metric.label,
        rangemode: "tozero",
        hoverformat: ".3f"
      },
      legend: {
        orientation: "h",
        yanchor: "bottom",
        y: -0.2,
        xanchor: "center",
        x: 0.5
      },
      margin: { l: 70, r: 30, t: 60, b: 80 },
      hoverlabel: { bgcolor: "#343a40", font: { color: "#fff" } }
    };

    const config = {
      responsive: true,
      displaylogo: false,
      modeBarButtonsToRemove: [
        "lasso2d",
        "select2d",
        "autoScale2d",
        "zoomIn2d",
        "zoomOut2d",
        "resetScale2d"
      ]
    };

    Plotly.react(chartEl, traces, layout, config);
  }

  function initialiseControls(clusters) {
    const clusterOptions = Array.from(clusters.values())
      .sort((a, b) => a.id - b.id)
      .map(cluster => {
        const sample = cluster.rows[0] || {};
        const labelParts = [];
        const shortLabel = cleanText(sample.short_label_kr);
        const micro = cleanText(sample.cluster_micro);
        if (shortLabel) {
          labelParts.push(shortLabel);
        }
        if (micro) {
          labelParts.push(micro);
        }
        const label = labelParts.length ? labelParts.join(" · ") : `Cluster ${cluster.id}`;
        return { value: cluster.id, label };
      });

    clusterSelect.innerHTML = "";
    clusterOptions.forEach(option => {
      const opt = document.createElement("option");
      opt.value = option.value;
      opt.textContent = `${option.value} · ${option.label}`;
      clusterSelect.appendChild(opt);
    });

    return clusterOptions;
  }

  function loadData() {
    Plotly.d3.csv(dataUrl, (err, rows) => {
      if (err) {
        console.error("Failed to load keyword time series.", err);
        metaEl.innerHTML = "<p>데이터를 불러오지 못했습니다. CSV 경로를 확인하세요.</p>";
        return;
      }

      const clusters = new Map();

      rows.forEach(rawRow => {
        const row = { ...rawRow };
        row.cluster_id = Number.parseInt(row.cluster_id, 10);
        row.year = row.year ? Number.parseInt(row.year, 10) : null;
        row.rank = row.rank ? Number.parseInt(row.rank, 10) : null;
        row.score = row.score ? Number.parseFloat(row.score) : null;
        row.ppm_series_val = row.ppm_series_val ? Number.parseFloat(row.ppm_series_val) : null;
        row.frequency = row.frequency ? Number.parseFloat(row.frequency) : null;

        if (!Number.isFinite(row.cluster_id)) {
          return;
        }

        const key = row.cluster_id;
        if (!clusters.has(key)) {
          clusters.set(key, { id: key, rows: [] });
        }
        clusters.get(key).rows.push(row);
      });

      if (!clusters.size) {
        metaEl.innerHTML = "<p>가공할 클러스터 데이터가 없습니다.</p>";
        return;
      }

      const options = initialiseControls(clusters);
      const initialClusterId = options[0]?.value;

      function handleUpdate() {
        const selectedId = Number.parseInt(clusterSelect.value, 10);
        const metricKey = metricSelect.value;
        const cluster = clusters.get(selectedId);
        if (!cluster) {
          return;
        }
        updateChart(cluster, metricKey);
        summariseCluster(cluster);
      }

      if (initialClusterId !== undefined) {
        clusterSelect.value = String(initialClusterId);
        handleUpdate();
      }

      clusterSelect.addEventListener("change", handleUpdate);
      metricSelect.addEventListener("change", handleUpdate);
    });
  }

  loadData();
})();
</script>
