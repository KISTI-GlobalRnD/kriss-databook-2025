---
title: "Keyword Trend Explorer / 키워드 추세 탐색기"
description: "Interactive plot of top-ranked keywords by research cluster and metric."
page-title: false
---

# Keyword Trend Explorer / 키워드 추세 탐색기

Interactively inspect how the highest-ranked keywords evolve across years for each research cluster.
Use the selectors to switch between clusters and metrics while the legend lets you toggle individual
keyword curves on and off. All data are sourced from the latest `_top5` time series export.

::: callout-tip
키워드 지표는 하나의 클러스터 안에서 점수(`score`), 문헌 비중(`ppm_series_val`), 출현 빈도(`frequency`)
중에서 선택할 수 있습니다. 범례를 클릭하면 개별 키워드를 강조하거나 숨길 수 있습니다.
:::

<style>
  .keyword-timeseries-wrapper {
    border: 1px solid #dee2e6;
    border-radius: 0.5rem;
    padding: 1.25rem;
    margin-bottom: 1.5rem;
    background: #f8f9fa;
  }
  .keyword-timeseries-controls {
    display: flex;
    flex-wrap: wrap;
    align-items: center;
    gap: 1.5rem;
    margin-bottom: 1.25rem;
  }
  .keyword-timeseries-controls label {
    display: block;
    font-weight: 600;
    margin-bottom: 0.35rem;
  }
  .keyword-timeseries-controls select {
    min-width: 16rem;
  }
  .keyword-timeseries-meta {
    margin-top: 1.25rem;
    font-size: 0.95rem;
    line-height: 1.55;
  }
  .keyword-timeseries-meta strong {
    font-weight: 600;
  }
  .keyword-timeseries-defs {
    margin-top: 1.75rem;
    padding: 1rem 1.2rem;
    border-left: 4px solid #2c7be5;
    background: #ffffff;
  }
  .keyword-timeseries-defs p {
    margin-bottom: 0.4rem;
  }
  .keyword-timeseries-defs p:last-child {
    margin-bottom: 0;
  }
</style>

<script src="https://cdn.plot.ly/plotly-2.27.1.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/d3@7/dist/d3.min.js"></script>

<div class="keyword-timeseries-wrapper">
<div class="keyword-timeseries-controls" id="keyword-timeseries-controls"></div>
<div id="keyword-timeseries-chart" style="width: 100%; min-height: 520px;"></div>
<div class="keyword-timeseries-meta" id="keyword-timeseries-meta"></div>
<div class="keyword-timeseries-defs">
  <p><strong>Document Share (PPM)</strong> · Parts per million of the cluster’s total unigram tokens for each term-year pair. \( \mathrm{PPM}_{c,y}(t) = 10^{6} \cdot \frac{n_{c,y}(t)}{N_{c,y}} \)</p>
  <p><strong>Score</strong> · Cluster-specific c‑TF‑IDF weight used to rank keywords (constant across years).</p>
  <p><strong>Frequency</strong> · Count of documents within the cluster that contain the keyword (constant across years).</p>
  <p>Both <em>Score</em> and <em>Frequency</em> appear inside the hover tooltips for each point.</p>
</div>
</div>

<script>
(() => {
  const dataUrl = "assets/keyword_top5_timeseries.csv";
  const chartEl = document.getElementById("keyword-timeseries-chart");
  const controlsEl = document.getElementById("keyword-timeseries-controls");
  const clusterGroup = document.createElement("div");
  const clusterLabel = document.createElement("label");
  clusterLabel.setAttribute("for", "cluster-select");
  clusterLabel.textContent = "Cluster / 클러스터";
  const clusterSelect = document.createElement("select");
  clusterSelect.id = "cluster-select";
  clusterSelect.setAttribute("aria-label", "Select cluster");
  clusterGroup.appendChild(clusterLabel);
  clusterGroup.appendChild(clusterSelect);
  controlsEl.appendChild(clusterGroup);
  const metaEl = document.getElementById("keyword-timeseries-meta");

  const metricKey = "ppm_series_val";
  const metricLabel = "Document Share (PPM)";

  function cleanText(value) {
    if (value === null || value === undefined) {
      return "";
    }
    const text = String(value).trim();
    if (!text) {
      return "";
    }
    const lower = text.toLowerCase();
    if (lower === "nan" || lower === "none" || lower === "null") {
      return "";
    }
    return text;
  }

  function summariseCluster(cluster) {
    const { id, rows } = cluster;
    const sample = rows[0] || {};
    const label = cleanText(sample.short_label_kr) || cleanText(sample.cluster_micro) || `Cluster ${id}`;
    const longLabel = cleanText(sample.long_label_kr);
    const summary = cleanText(sample.summary_kr);

    const keywordsEnRaw = cleanText(sample.keywords_en);
    const keywordsKrRaw = cleanText(sample.keywords_kr);
    const keywordsEn = keywordsEnRaw
      ? keywordsEnRaw.split(",").map(part => part.trim()).filter(Boolean).slice(0, 5).join(", ")
      : "";
    const keywordsKr = keywordsKrRaw
      ? keywordsKrRaw.split(",").map(part => part.trim()).filter(Boolean).slice(0, 5).join(", ")
      : "";

    const termList = Array.from(new Set(rows.map(r => r.term))).slice(0, 5);

    const lines = [
      `<strong>${label}</strong>${longLabel ? ` (${longLabel})` : ""}`,
      termList.length ? `Top terms: ${termList.join(", ")}` : "",
      keywordsEn ? `Keywords (EN): ${keywordsEn}` : "",
      keywordsKr ? `키워드 (KO): ${keywordsKr}` : "",
      summary ? `요약: ${summary}` : ""
    ].filter(Boolean);

    metaEl.innerHTML = lines.map(line => `<p>${line}</p>`).join("");
  }

  function buildTraces(cluster) {
    const rowsByTerm = new Map();
    cluster.rows.forEach(row => {
      const termRows = rowsByTerm.get(row.term) || [];
      termRows.push(row);
      rowsByTerm.set(row.term, termRows);
    });

    const traces = [];
    rowsByTerm.forEach((termRows, term) => {
      const sorted = termRows
        .filter(r => r.year !== null && r.year !== undefined && !Number.isNaN(r.year))
        .sort((a, b) => a.year - b.year);
      if (!sorted.length) {
        return;
      }
      traces.push({
        name: term,
        x: sorted.map(r => r.year),
        y: sorted.map(r => r[metricKey]),
        hovertemplate:
          "<b>%{customdata[0]}</b><br>" +
          "Year: %{x}<br>" +
          "Document Share (PPM): %{y:.2f}<br>" +
          "Score: %{customdata[1]:.3f}<br>" +
          "Frequency: %{customdata[2]:,.0f}<extra></extra>",
        customdata: sorted.map(r => [term, r.score ?? null, r.frequency ?? null]),
        mode: "lines+markers",
        line: { width: 2 },
        marker: { size: 6 }
      });
    });
    return traces;
  }

  function updateChart(cluster) {
    const traces = buildTraces(cluster);
    const years = cluster.rows
      .map(r => r.year)
      .filter(year => year !== null && year !== undefined && !Number.isNaN(year));
    const minYear = years.length ? Math.min(...years) : null;
    const maxYear = years.length ? Math.max(...years) : null;

    const layout = {
      title: {
        text: `Cluster ${cluster.id} · ${metricLabel}`,
        font: { size: 20 }
      },
      xaxis: {
        title: "Year",
        dtick: 1,
        range: minYear !== null && maxYear !== null ? [minYear - 0.5, maxYear + 0.5] : undefined,
        tickformat: "d",
        hoverformat: "d"
      },
      yaxis: {
        title: metricLabel,
        rangemode: "tozero",
        hoverformat: ".2f"
      },
      legend: {
        orientation: "h",
        yanchor: "bottom",
        y: -0.2,
        xanchor: "center",
        x: 0.5
      },
      margin: { l: 70, r: 30, t: 60, b: 80 },
      hoverlabel: { bgcolor: "#343a40", font: { color: "#fff" } }
    };

    const config = {
      responsive: true,
      displaylogo: false,
      modeBarButtonsToRemove: [
        "lasso2d",
        "select2d",
        "autoScale2d",
        "zoomIn2d",
        "zoomOut2d",
        "resetScale2d"
      ]
    };

    Plotly.react(chartEl, traces, layout, config);
  }

  function initialiseControls(clusters) {
    const clusterOptions = Array.from(clusters.values())
      .sort((a, b) => a.id - b.id)
      .map(cluster => {
        const sample = cluster.rows[0] || {};
        const labelParts = [];
        const shortLabel = cleanText(sample.short_label_kr);
        const micro = cleanText(sample.cluster_micro);
        if (shortLabel) {
          labelParts.push(shortLabel);
        }
        if (micro) {
          labelParts.push(micro);
        }
        const label = labelParts.length ? labelParts.join(" · ") : `Cluster ${cluster.id}`;
        return { value: cluster.id, label };
      });

    clusterSelect.innerHTML = "";
    if (!clusterOptions.length) {
      clusterSelect.disabled = true;
      clusterSelect.innerHTML = "<option>No clusters available</option>";
      return clusterOptions;
    }

    clusterOptions.forEach(option => {
      const opt = document.createElement("option");
      opt.value = option.value;
      opt.textContent = `${option.value} · ${option.label}`;
      clusterSelect.appendChild(opt);
    });

    return clusterOptions;
  }

  function loadData() {
    d3.csv(dataUrl).then(rows => {
      const clusters = new Map();

      rows.forEach(rawRow => {
        if (!rawRow) {
          return;
        }
        const row = { ...rawRow };
        row.cluster_id = Number.parseInt(row.cluster_id, 10);
        row.year = row.year ? Number.parseInt(row.year, 10) : null;
        row.rank = row.rank ? Number.parseInt(row.rank, 10) : null;
        row.score = row.score ? Number.parseFloat(row.score) : null;
        row.ppm_series_val = row.ppm_series_val ? Number.parseFloat(row.ppm_series_val) : null;
        row.frequency = row.frequency ? Number.parseFloat(row.frequency) : null;

        if (!Number.isFinite(row.cluster_id)) {
          return;
        }

        const key = row.cluster_id;
        if (!clusters.has(key)) {
          clusters.set(key, { id: key, rows: [] });
        }
        clusters.get(key).rows.push(row);
      });

      if (!clusters.size) {
        metaEl.innerHTML = "<p>가공할 클러스터 데이터가 없습니다.</p>";
        return;
      }

      const options = initialiseControls(clusters);
      const initialClusterId = options[0]?.value;

      function handleUpdate() {
        const selectedId = Number.parseInt(clusterSelect.value, 10);
        const cluster = clusters.get(selectedId);
        if (!cluster) {
          metaEl.innerHTML = "<p>선택한 클러스터에 대한 데이터가 없습니다.</p>";
          Plotly.purge(chartEl);
          return;
        }
        updateChart(cluster);
        summariseCluster(cluster);
      }

      if (initialClusterId !== undefined) {
        clusterSelect.value = String(initialClusterId);
        handleUpdate();
      }

      clusterSelect.addEventListener("change", handleUpdate);
    }).catch(err => {
      console.error("Failed to load keyword time series.", err);
      metaEl.innerHTML = "<p>데이터를 불러오지 못했습니다. CSV 경로 또는 접근 권한을 확인하세요.</p>";
    });
  }

  loadData();
})();
</script>
